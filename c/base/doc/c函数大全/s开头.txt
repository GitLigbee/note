函数大全(s开头)
函数名: sbrk 
功 能: 改变数据段空间位置 
用 法: char *sbrk(int incr); 
程序例: 

#include 
#include 

int main(void) 
{ 
printf("Changing allocation with sbrk()\n"); 
printf("Before sbrk() call: %lu bytes free\n", 
(unsigned long) coreleft()); 
sbrk(1000); 
printf(" After sbrk() call: %lu bytes free\n", 
(unsigned long) coreleft()); 
return 0; 
} 



函数名: scanf 
功 能: 执行格式化输入 
用 法: int scanf(char *format[,argument,...]); 
程序例: 

#include 
#include 

int main(void) 
{ 
char label[20]; 
char name[20]; 
int entries = 0; 
int loop, age; 
double salary; 

struct Entry_struct 
{ 
char name[20]; 
int age; 
float salary; 
} entry[20]; 

/* Input a label as a string of characters restricting to 20 characters */ 
printf("\n\nPlease enter a label for the chart: "); 
scanf("%20s", label); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* Input number of entries as an integer */ 
printf("How many entries will there be? (less than 20) "); 
scanf("%d", &entries); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a name restricting input to only letters upper or lower case */ 
for (loop=0;loop { 
printf("Entry %d\n", loop); 
printf(" Name : "); 
scanf("%[A-Za-z]", entry[loop].name); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input an age as an integer */ 
printf(" Age : "); 
scanf("%d", &entry[loop].age); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a salary as a float */ 
printf(" Salary : "); 
scanf("%f", &entry[loop].salary); 
fflush(stdin); /* flush the input stream in case of bad input */ 
} 

/* Input a name, age and salary as a string, integer, and double */ 
printf("\nPlease enter your name, age and salary\n"); 
scanf("%20s %d %lf", name, &age, &salary); 


/* Print out the data that was input */ 
printf("\n\nTable %s\n",label); 
printf("Compiled by %s age %d $%15.2lf\n", name, age, salary); 
printf("-----------------------------------------------------\n"); 
for (loop=0;loop printf("%4d | %-20s | %5d | %15.2lf\n", 
loop + 1, 
entry[loop].name, 
entry[loop].age, 
entry[loop].salary); 
printf("-----------------------------------------------------\n"); 
return 0; 
} 



函数名: searchpath 
功 能: 搜索DOS路径 
用 法: char *searchpath(char *filename); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *p; 

/* Looks for TLINK and returns a pointer 
to the path */ 
p = searchpath("TLINK.EXE"); 
printf("Search for TLINK.EXE : %s\n", p); 

/* Looks for non-existent file */ 
p = searchpath("NOTEXIST.FIL"); 
printf("Search for NOTEXIST.FIL : %s\n", p); 

return 0; 
} 



函数名: sector 
功 能: 画并填充椭圆扇区 
用 法: void far sector(int x, int y, int stangle, int endangle); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int midx, midy, i; 
int stangle = 45, endangle = 135; 
int xrad = 100, yrad = 50; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

/* loop through the fill patterns */ 
for (i=EMPTY_FILL; i { 
/* set the fill style */ 
setfillstyle(i, getmaxcolor()); 

/* draw the sector slice */ 
sector(midx, midy, stangle, endangle, xrad, yrad); 

getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 


函数名: segread 
功 能: 读段寄存器值 
用 法: void segread(struct SREGS *segtbl); 
程序例: 

#include 
#include 

int main(void) 
{ 
struct SREGS segs; 

segread(&segs); 
printf("Current segment register settings\n\n"); 
printf("CS: %X DS: %X\n", segs.cs, segs.ds); 
printf("ES: %X SS: %X\n", segs.es, segs.ss); 

return 0; 
} 



函数名: setactivepage 
功 能: 设置图形输出活动页 
用 法: void far setactivepage(int pagenum); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple pages. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int x, y, ht; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

x = getmaxx() / 2; 
y = getmaxy() / 2; 
ht = textheight("W"); 

/* select the off screen page for drawing */ 
setactivepage(1); 

/* draw a line on page #1 */ 
line(0, 0, getmaxx(), getmaxy()); 

/* output a message on page #1 */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, "This is page #1:"); 
outtextxy(x, y+ht, "Press any key to halt:"); 

/* select drawing to page #0 */ 
setactivepage(0); 

/* output a message on page #0 */ 
outtextxy(x, y, "This is page #0."); 
outtextxy(x, y+ht, "Press any key to view page #1:"); 
getch(); 

/* select page #1 as the visible page */ 
setvisualpage(1); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setallpallette 
功 能: 按指定方式改变所有的调色板颜色 
用 法: void far setallpallette(struct palette, far *pallette); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
struct palettetype pal; 
int color, maxcolor, ht; 
int y = 10; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

maxcolor = getmaxcolor(); 
ht = 2 * textheight("W"); 

/* grab a copy of the palette */ 
getpalette(&pal); 

/* display the default palette colors */ 
for (color=1; color<=maxcolor; color++) 
{ 
setcolor(color); 
sprintf(msg, "Color: %d", color); 
outtextxy(1, y, msg); 
y += ht; 
} 

/* wait for a key */ 
getch(); 

/* black out the colors one by one */ 
for (color=1; color<=maxcolor; color++) 
{ 
setpalette(color, BLACK); 
getch(); 
} 

/* restore the palette colors */ 
setallpalette(&pal); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setaspectratio 
功 能: 设置图形纵横比 
用 法: void far setaspectratio(int xasp, int yasp); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int xasp, yasp, midx, midy; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 
setcolor(getmaxcolor()); 

/* get current aspect ratio settings */ 
getaspectratio(&xasp, &yasp); 

/* draw normal circle */ 
circle(midx, midy, 100); 
getch(); 

/* claer the screen */ 
cleardevice(); 

/* adjust the aspect for a wide circle */ 
setaspectratio(xasp/2, yasp); 
circle(midx, midy, 100); 
getch(); 

/* adjust the aspect for a narrow circle */ 
cleardevice(); 
setaspectratio(xasp, yasp/2); 
circle(midx, midy, 100); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setbkcolor 
功 能: 用调色板设置当前背景颜色 
用 法: void far setbkcolor(int color); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple background colors. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int bkcol, maxcolor, x, y; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

/* maximum color index supported */ 
maxcolor = getmaxcolor(); 

/* for centering text messages */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
x = getmaxx() / 2; 
y = getmaxy() / 2; 

/* loop through the available colors */ 
for (bkcol=0; bkcol<=maxcolor; bkcol++) 
{ 
/* clear the screen */ 
cleardevice(); 

/* select a new background color */ 
setbkcolor(bkcol); 

/* output a messsage */ 
if (bkcol == WHITE) 
setcolor(EGA_BLUE); 
sprintf(msg, "Background color: %d", bkcol); 
outtextxy(x, y, msg); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: setblock 
功 能: 修改先前已分配的DOS存储段大小 
用 法: int setblock(int seg, int newsize); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
unsigned int size, segp; 
int stat; 

size = 64; /* (64 x 16) = 1024 bytes */ 
stat = allocmem(size, &segp); 
if (stat == -1) 
printf("Allocated memory at segment: %X\n", segp); 
else 
{ 
printf("Failed: maximum number of paragraphs available is %d\n", 
stat); 
exit(1); 
} 

stat = setblock(segp, size * 2); 
if (stat == -1) 
printf("Expanded memory block at segment: %X\n", segp); 
else 
printf("Failed: maximum number of paragraphs available is %d\n", 
stat); 

freemem(segp); 

return 0; 
} 



函数名: setbuf 
功 能: 把缓冲区与流相联 
用 法: void setbuf(FILE *steam, char *buf); 
程序例: 

#include 

/* BUFSIZ is defined in stdio.h */ 
char outbuf[BUFSIZ]; 

int main(void) 
{ 
/* attach a buffer to the standard output stream */ 
setbuf(stdout, outbuf); 

/* put some characters into the buffer */ 
puts("This is a test of buffered output.\n\n"); 
puts("This output will go into outbuf\n"); 
puts("and won't appear until the buffer\n"); 
puts("fills up or we flush the stream.\n"); 

/* flush the output buffer */ 
fflush(stdout); 

return 0; 
} 



函数名: setcbrk 
功 能: 设置Control-break 
用 法: int setcbrk(int value); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
int break_flag; 

printf("Enter 0 to turn control break off\n"); 
printf("Enter 1 to turn control break on\n"); 

break_flag = getch() - 0; 

setcbrk(break_flag); 

if (getcbrk()) 
printf("Cntrl-brk flag is on\n"); 
else 
printf("Cntrl-brk flag is off\n"); 
return 0; 
} 




函数名: setcolor 
功 能: 设置当前画线颜色 
用 法: void far setcolor(int color); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple drawing colors. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int color, maxcolor, x, y; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

/* maximum color index supported */ 
maxcolor = getmaxcolor(); 

/* for centering text messages */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
x = getmaxx() / 2; 
y = getmaxy() / 2; 

/* loop through the available colors */ 
for (color=1; color<=maxcolor; color++) 
{ 
/* clear the screen */ 
cleardevice(); 

/* select a new background color */ 
setcolor(color); 

/* output a messsage */ 
sprintf(msg, "Color: %d", color); 
outtextxy(x, y, msg); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: setdate 
功 能: 设置DOS日期 
用 法: void setdate(struct date *dateblk); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
struct date reset; 
struct date save_date; 

getdate(&save_date); 
printf("Original date:\n"); 
system("date"); 

reset.da_year = 2001; 
reset.da_day = 1; 
reset.da_mon = 1; 
setdate(&reset); 

printf("Date after setting:\n"); 
system("date"); 

setdate(&save_date); 
printf("Back to original date:\n"); 
system("date"); 

return 0; 
} 



函数名: setdisk 
功 能: 设置当前磁盘驱动器 
用 法: int setdisk(int drive); 
程序例: 

#include 
#include 

int main(void) 
{ 
int save, disk, disks; 

/* save original drive */ 
save = getdisk(); 

/* print number of logic drives */ 
disks = setdisk(save); 
printf("%d logical drives on the system\n\n", disks); 

/* print the drive letters available */ 
printf("Available drives:\n"); 
for (disk = 0;disk < 26;++disk) 
{ 
setdisk(disk); 
if (disk == getdisk()) 
printf("%c: drive is available\n", disk + 'a'); 
} 
setdisk(save); 

return 0; 
} 



函数名: setdta 
功 能: 设置磁盘传输区地址 
用 法: void setdta(char far *dta); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
char line[80], far *save_dta; 
char buffer[256] = "SETDTA test!"; 
struct fcb blk; 
int result; 

/* get new file name from user */ 
printf("Enter a file name to create:"); 
gets(line); 

/* parse the new file name to the dta */ 
parsfnm(line, &blk, 1); 
printf("%d %s\n", blk.fcb_drive, blk.fcb_name); 

/* request DOS services to create file */ 
if (bdosptr(0x16, &blk, 0) == -1) 
{ 
perror("Error creating file"); 
exit(1); 
} 

/* save old dta and set new dta */ 
save_dta = getdta(); 
setdta(buffer); 

/* write new records */ 
blk.fcb_recsize = 256; 
blk.fcb_random = 0L; 
result = randbwr(&blk, 1); 
printf("result = %d\n", result); 

if (!result) 
printf("Write OK\n"); 
else 
{ 
perror("Disk error"); 
exit(1); 
} 

/* request DOS services to close the file */ 
if (bdosptr(0x10, &blk, 0) == -1) 
{ 
perror("Error closing file"); 
exit(1); 
} 

/* reset the old dta */ 
setdta(save_dta); 
return 0; 
} 



函数名: setfillpattern 
功 能: 选择用户定义的填充模式 
用 法: void far setfillpattern(char far *upattern, int color); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int maxx, maxy; 

/* a user defined fill pattern */ 
char pattern[8] = {0x00, 0x70, 0x20, 0x27, 0x24, 0x24, 0x07, 0x00}; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

maxx = getmaxx(); 
maxy = getmaxy(); 
setcolor(getmaxcolor()); 

/* select a user defined fill pattern */ 
setfillpattern(pattern, getmaxcolor()); 

/* fill the screen with the pattern */ 
bar(0, 0, maxx, maxy); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setfillstyle 
功 能: 设置填充模式和颜色 
用 法: void far setfillstyle(int pattern, int color); 
程序例: 

#include 
#include 
#include 
#include 
#include 

/* the names of the fill styles supported */ 
char *fname[] = { "EMPTY_FILL", 
"SOLID_FILL", 
"LINE_FILL", 
"LTSLASH_FILL", 
"SLASH_FILL", 
"BKSLASH_FILL", 
"LTBKSLASH_FILL", 
"HATCH_FILL", 
"XHATCH_FILL", 
"INTERLEAVE_FILL", 
"WIDE_DOT_FILL", 
"CLOSE_DOT_FILL", 
"USER_FILL" 
}; 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int style, midx, midy; 
char stylestr[40]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

for (style = EMPTY_FILL; style < USER_FILL; style++) 
{ 
/* select the fill style */ 
setfillstyle(style, getmaxcolor()); 

/* convert style into a string */ 
strcpy(stylestr, fname[style]); 

/* fill a bar */ 
bar3d(0, 0, midx-10, midy, 0, 0); 

/* output a message */ 
outtextxy(midx, midy, stylestr); 

/* wait for a key */ 
getch(); 
cleardevice(); 
} 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setftime 
功 能: 设置文件日期和时间 
用 法: int setftime(int handle, struct ftime *ftimep); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
struct ftime filet; 
FILE *fp; 

if ((fp = fopen("TEST.$$$", "w")) == NULL) 
{ 
perror("Error:"); 
exit(1); 
} 

fprintf(fp, "testing...\n"); 

/* load ftime structure with new time and date */ 
filet.ft_tsec = 1; 
filet.ft_min = 1; 
filet.ft_hour = 1; 
filet.ft_day = 1; 
filet.ft_month = 1; 
filet.ft_year = 21; 

/* show current directory for time and date */ 
system("dir TEST.$$$"); 

/* change the time and date stamp*/ 
setftime(fileno(fp), &filet); 

/* close and remove the temporary file */ 
fclose(fp); 

system("dir TEST.$$$"); 

unlink("TEST.$$$"); 
return 0; 
} 



函数名: setgraphbufsize 
功 能: 改变内部图形缓冲区的大小 
用 法: unsigned far setgraphbufsize(unsigned bufsize); 
程序例: 

#include 
#include 
#include 
#include 

#define BUFSIZE 1000 /* internal graphics buffer size */ 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int x, y, oldsize; 
char msg[80]; 

/* set the size of the internal graphics buffer */ 
/* before making a call to initgraph. */ 
oldsize = setgraphbufsize(BUFSIZE); 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

x = getmaxx() / 2; 
y = getmaxy() / 2; 

/* output some messages */ 
sprintf(msg, "Graphics buffer size: %d", BUFSIZE); 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, msg); 
sprintf(msg, "Old graphics buffer size: %d", oldsize); 
outtextxy(x, y+textheight("W"), msg); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 




函数名: setgraphmode 
功 能: 将系统设置成图形模式且清屏 
用 法: void far setgraphmode(int mode); 
程序例: 

#include 
#include 
#include #include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int x, y; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

x = getmaxx() / 2; 
y = getmaxy() / 2; 

/* output a message */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, "Press any key to exit graphics:"); 
getch(); 

/* restore system to text mode */ 
restorecrtmode(); 
printf("We're now in text mode.\n"); 
printf("Press any key to return to graphics mode:"); 
getch(); 

/* return to graphics mode */ 
setgraphmode(getgraphmode()); 

/* output a message */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, "We're back in graphics mode."); 
outtextxy(x, y+textheight("W"), "Press any key to halt:"); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 




函数名: setjmp 
功 能: 非局部转移 
用 法: int setjmp(jmp_buf env); 
程序例: 

#include 
#include 
#include 

void subroutine(void); 

jmp_buf jumper; 

int main(void) 
{ 
int value; 

value = setjmp(jumper); 
if (value != 0) 
{ 
printf("Longjmp with value %d\n", value); 
exit(value); 
} 
printf("About to call subroutine ... \n"); 
subroutine(); 
return 0; 
} 

void subroutine(void) 
{ 
longjmp(jumper,1); 
} 



函数名: setlinestyle 
功 能: 设置当前画线宽度和类型 
用 法: void far setlinestyle(int linestype, unsigned upattern); 
程序例: 

#include 
#include 
#include 
#include 
#include 

/* the names of the line styles supported */ 
char *lname[] = { 
"SOLID_LINE", 
"DOTTED_LINE", 
"CENTER_LINE", 
"DASHED_LINE", 
"USERBIT_LINE" 
}; 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 

int style, midx, midy, userpat; 
char stylestr[40]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

/* a user defined line pattern */ 
/* binary: "0000000000000001" */ 
userpat = 1; 

for (style=SOLID_LINE; style<=USERBIT_LINE; style++) 
{ 
/* select the line style */ 
setlinestyle(style, userpat, 1); 

/* convert style into a string */ 
strcpy(stylestr, lname[style]); 

/* draw a line */ 
line(0, 0, midx-10, midy); 

/* draw a rectangle */ 
rectangle(0, 0, getmaxx(), getmaxy()); 

/* output a message */ 
outtextxy(midx, midy, stylestr); 

/* wait for a key */ 
getch(); 
cleardevice(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 




函数名: setmem 
功 能: 存值到存储区 
用 法: void setmem(void *addr, int len, char value); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
char *dest; 

dest = calloc(21, sizeof(char)); 
setmem(dest, 20, 'c'); 
printf("%s\n", dest); 

return 0; 
} 




函数名: setmode 
功 能: 设置打开文件方式 
用 法: int setmode(int handle, unsigned mode); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
int result; 

result = setmode(fileno(stdprn), O_TEXT); 
if (result == -1) 
perror("Mode not available\n"); 
else 
printf("Mode successfully switched\n"); 
return 0; 
} 




函数名: setpalette 
功 能: 改变调色板的颜色 
用 法: void far setpalette(int index, int actural_color); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int color, maxcolor, ht; 
int y = 10; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

maxcolor = getmaxcolor(); 
ht = 2 * textheight("W"); 

/* display the default colors */ 
for (color=1; color<=maxcolor; color++) 
{ 
setcolor(color); 
sprintf(msg, "Color: %d", color); 
outtextxy(1, y, msg); 
y += ht; 
} 

/* wait for a key */ 
getch(); 

/* black out the colors one by one */ 
for (color=1; color<=maxcolor; color++) 
{ 
setpalette(color, BLACK); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: setrgbpalette 
功 能: 定义IBM8514图形卡的颜色 
用 法: void far setrgbpalette(int colornum, int red, int green, int blue); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* select a driver and mode that supports the use */ 
/* of the setrgbpalette function. */ 
int gdriver = VGA, gmode = VGAHI, errorcode; 
struct palettetype pal; 
int i, ht, y, xmax; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

/* grab a copy of the palette */ 
getpalette(&pal); 

/* create gray scale */ 
for (i=0; i setrgbpalette(pal.colors[i], i*4, i*4, i*4); 

/* display the gray scale */ 
ht = getmaxy() / 16; 
xmax = getmaxx(); 
y = 0; 
for (i=0; i { 
setfillstyle(SOLID_FILL, i); 
bar(0, y, xmax, y+ht); 
y += ht; 
} 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 




函数名: settextjustify 
功 能: 为图形函数设置文本的对齐方式 
用 法: void far settextjustify(int horiz, int vert); 
程序例: 

#include 
#include 
#include 
#include 

/* function prototype */ 
void xat(int x, int y); 

/* horizontal text justification settings */ 
char *hjust[] = { "LEFT_TEXT", 
"CENTER_TEXT", 
"RIGHT_TEXT" 
}; 

/* vertical text justification settings */ 
char *vjust[] = { "LEFT_TEXT", 
"CENTER_TEXT", 
"RIGHT_TEXT" 
}; 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int midx, midy, hj, vj; 
char msg[80]; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

/* loop through text justifications */ 
for (hj=LEFT_TEXT; hj<=RIGHT_TEXT; hj++) 
for (vj=LEFT_TEXT; vj<=RIGHT_TEXT; vj++) 
{ 
cleardevice(); 
/* set the text justification */ 
settextjustify(hj, vj); 

/* create a message string */ 
sprintf(msg, "%s %s", hjust[hj], vjust[vj]); 

/* create cross hairs on the screen */ 
xat(midx, midy); 

/* output the message */ 
outtextxy(midx, midy, msg); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 

/* draw an "x" at (x, y) */ 
void xat(int x, int y) 
{ 
line(x-4, y, x+4, y); 
line(x, y-4, x, y+4); 
} 



函数名: settextstyle 
功 能: 为图形输出设置当前的文本属性 
用 法: void far settextstyle (int font, int direction, char size); 
程序例: 

#include 
#include 
#include 
#include 

/* the names of the text styles supported */ 
char *fname[] = { "DEFAULT font", 
"TRIPLEX font", 
"SMALL font", 
"SANS SERIF font", 
"GOTHIC font" 
}; 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int style, midx, midy; 
int size = 1; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

settextjustify(CENTER_TEXT, CENTER_TEXT); 

/* loop through the available text styles */ 
for (style=DEFAULT_FONT; style<=GOTHIC_FONT; style++) 
{ 
cleardevice(); 
if (style == TRIPLEX_FONT) 
size = 4; 

/* select the text style */ 
settextstyle(style, HORIZ_DIR, size); 

/* output a message */ 
outtextxy(midx, midy, fname[style]); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: settextstyle 
功 能: 为图形输出设置当前的文本属性 
用 法: void far settextstyle (int font, int direction, char size); 
程序例: 

#include 
#include 
#include 
#include 

/* the names of the text styles supported */ 
char *fname[] = { "DEFAULT font", 
"TRIPLEX font", 
"SMALL font", 
"SANS SERIF font", 
"GOTHIC font" 
}; 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int style, midx, midy; 
int size = 1; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

midx = getmaxx() / 2; 
midy = getmaxy() / 2; 

settextjustify(CENTER_TEXT, CENTER_TEXT); 

/* loop through the available text styles */ 
for (style=DEFAULT_FONT; style<=GOTHIC_FONT; style++) 
{ 
cleardevice(); 
if (style == TRIPLEX_FONT) 
size = 4; 

/* select the text style */ 
settextstyle(style, HORIZ_DIR, size); 

/* output a message */ 
outtextxy(midx, midy, fname[style]); 
getch(); 
} 

/* clean up */ 
closegraph(); 
return 0; 
} 



函数名: settime 
功 能: 设置系统时间 
用 法: void settime(struct time *timep); 
程序例: 

#include 
#include 

int main(void) 
{ 
struct time t; 

gettime(&t); 
printf("The current minute is: %d\n", t.ti_min); 
printf("The current hour is: %d\n", t.ti_hour); 
printf("The current hundredth of a second is: %d\n", t.ti_hund); 
printf("The current second is: %d\n", t.ti_sec); 

/* Add one to the minutes struct element and then call settime */ 
t.ti_min++; 
settime(&t); 

return 0; 
} 



函数名: setusercharsize 
功 能: 为矢量字体改变字符宽度和高度 
用 法: void far setusercharsize(int multx, int dirx, int multy, int diry); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* request autodetection */ 
int gdriver = DETECT, gmode, errorcode; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

/* select a text style */ 
settextstyle(TRIPLEX_FONT, HORIZ_DIR, 4); 

/* move to the text starting position */ 
moveto(0, getmaxy() / 2); 

/* output some normal text */ 
outtext("Norm "); 

/* make the text 1/3 the normal width */ 
setusercharsize(1, 3, 1, 1); 
outtext("Short "); 

/* make the text 3 times normal width */ 
setusercharsize(3, 1, 1, 1); 
outtext("Wide"); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 


函数名: setvbuf 
功 能: 把缓冲区与流相关 
用 法: int setvbuf(FILE *stream, char *buf, int type, unsigned size); 
程序例: 

#include 

int main(void) 
{ 
FILE *input, *output; 
char bufr[512]; 

input = fopen("file.in", "r+b"); 
output = fopen("file.out", "w"); 

/* set up input stream for minimal disk access, 
using our own character buffer */ 
if (setvbuf(input, bufr, _IOFBF, 512) != 0) 
printf("failed to set up buffer for input file\n"); 
else 
printf("buffer set up for input file\n"); 

/* set up output stream for line buffering using space that 
will be obtained through an indirect call to malloc */ 
if (setvbuf(output, NULL, _IOLBF, 132) != 0) 
printf("failed to set up buffer for output file\n"); 
else 
printf("buffer set up for output file\n"); 

/* perform file I/O here */ 

/* close files */ 
fclose(input); 
fclose(output); 
return 0; 
} 




函数名: setvect 
功 能: 设置中断矢量入口 
用 法: void setvect(int intr_num, void interrupt(*isr)()); 
程序例: 

/***NOTE: 
This is an interrupt service routine. You can NOT compile this 
program with Test Stack Overflow turned on and get an executable 
file which will operate correctly. */ 

#include 
#include 
#include 

#define INTR 0X1C /* The clock tick interrupt */ 

void interrupt ( *oldhandler)(void); 

int count=0; 

void interrupt handler(void) 
{ 
/* increase the global counter */ 
count++; 

/* call the old routine */ 
oldhandler(); 
} 

int main(void) 
{ 
/* save the old interrupt vector */ 
oldhandler = getvect(INTR); 

/* install the new interrupt handler */ 
setvect(INTR, handler); 

/* loop until the counter exceeds 20 */ 
while (count < 20) 
printf("count is %d\n",count); 

/* reset the old interrupt handler */ 
setvect(INTR, oldhandler); 

return 0; 
} 



函数名: setverify 
功 能: 设置验证状态 
用 法: void setverify(int value); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
int verify_flag; 

printf("Enter 0 to set verify flag off\n"); 
printf("Enter 1 to set verify flag on\n"); 

verify_flag = getch() - 0; 

setverify(verify_flag); 

if (getverify()) 
printf("DOS verify flag is on\n"); 
else 
printf("DOS verify flag is off\n"); 

return 0; 
} 



函数名: setviewport 
功 能: 为图形输出设置当前视口 
用 法: void far setviewport(int left, int top, int right, 
int bottom, int clipflag); 
程序例: 

#include 
#include 
#include 
#include 

#define CLIP_ON 1 /* activates clipping in viewport */ 

int main(void) 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

setcolor(getmaxcolor()); 

/* message in default full-screen viewport */ 
outtextxy(0, 0, "* <-- (0, 0) in default viewport"); 

/* create a smaller viewport */ 
setviewport(50, 50, getmaxx()-50, getmaxy()-50, CLIP_ON); 

/* display some text */ 
outtextxy(0, 0, "* <-- (0, 0) in smaller viewport"); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setvisualpage 
功 能: 设置可见图形页号 
用 法: void far setvisualpage(int pagenum); 
程序例: 

#include 
#include 
#include 
#include 

int main(void) 
{ 
/* select a driver and mode that supports */ 
/* multiple pages. */ 
int gdriver = EGA, gmode = EGAHI, errorcode; 
int x, y, ht; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

x = getmaxx() / 2; 
y = getmaxy() / 2; 
ht = textheight("W"); 

/* select the off screen page for drawing */ 
setactivepage(1); 

/* draw a line on page #1 */ 
line(0, 0, getmaxx(), getmaxy()); 

/* output a message on page #1 */ 
settextjustify(CENTER_TEXT, CENTER_TEXT); 
outtextxy(x, y, "This is page #1:"); 
outtextxy(x, y+ht, "Press any key to halt:"); 

/* select drawing to page #0 */ 
setactivepage(0); 

/* output a message on page #0 */ 
outtextxy(x, y, "This is page #0."); 
outtextxy(x, y+ht, "Press any key to view page #1:"); 
getch(); 

/* select page #1 as the visible page */ 
setvisualpage(1); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: setwritemode 
功 能: 设置图形方式下画线的输出模式 
用 法: void far setwritemode(int mode); 
程序例: 

#include 
#include 
#include 
#include 

int main() 
{ 
/* request auto detection */ 
int gdriver = DETECT, gmode, errorcode; 
int xmax, ymax; 

/* initialize graphics and local variables */ 
initgraph(&gdriver, &gmode, ""); 

/* read result of initialization */ 
errorcode = graphresult(); 
if (errorcode != grOk) /* an error occurred */ 
{ 
printf("Graphics error: %s\n", grapherrormsg(errorcode)); 
printf("Press any key to halt:"); 
getch(); 
exit(1); /* terminate with an error code */ 
} 

xmax = getmaxx(); 
ymax = getmaxy(); 

/* select XOR drawing mode */ 
setwritemode(XOR_PUT); 

/* draw a line */ 
line(0, 0, xmax, ymax); 
getch(); 

/* erase the line by drawing over it */ 
line(0, 0, xmax, ymax); 
getch(); 

/* select overwrite drawing mode */ 
setwritemode(COPY_PUT); 

/* draw a line */ 
line(0, 0, xmax, ymax); 

/* clean up */ 
getch(); 
closegraph(); 
return 0; 
} 



函数名: signal 
功 能: 设置某一信号的对应动作 
用 法: int signal(int sig, sigfun fname); 
程序例: 

/* This example installs a signal handler routine for SIGFPE, 
catches an integer overflow condition, makes an adjustment 
to AX register, and returns. This example program MAY cause 
your computer to crash, and will produce runtime errors 
depending on which memory model is used. 
*/ 

#pragma inline 
#include 
#include 

void Catcher(int sig, int type, int *reglist) 
{ 
printf("Caught it!\n"); 
*(reglist + 8) = 3; /* make return AX = 3 */ 
} 

int main(void) 
{ 
signal(SIGFPE, Catcher); 
asm mov ax,07FFFH /* AX = 32767 */ 
asm inc ax /* cause overflow */ 
asm into /* activate handler */ 

/* The handler set AX to 3 on return. If that hadn't happened, 
there would have been another exception when the next 'into' 
was executed after the 'dec' instruction. */ 
asm dec ax /* no overflow now */ 
asm into /* doesn't activate */ 
return 0; 
} 




函数名: sin 
功 能: 正弦函数 
用 法: double sin(double x); 
程序例: 

#include 
#include 

int main(void) 
{ 
double result, x = 0.5; 

result = sin(x); 
printf("The sin() of %lf is %lf\n", x, result); 
return 0; 
} 



函数名: sinh 
功 能: 双曲正弦函数 
用 法: double sinh(double x); 
程序例: 

#include 
#include 

int main(void) 
{ 
double result, x = 0.5; 

result = sinh(x); 
printf("The hyperbolic sin() of %lf is %lf\n", x, result); 
return 0; 
} 




函数名: sleep 
功 能: 执行挂起一段时间 
用 法: unsigned sleep(unsigned seconds); 
程序例: 

#include 
#include 

int main(void) 
{ 
int i; 

for (i=1; i<5; i++) 
{ 
printf("Sleeping for %d seconds\n", i); 
sleep(i); 
} 
return 0; 
} 




函数名: sopen 
功 能: 打开一共享文件 
用 法: int sopen(char *pathname, int access, int shflag, int permiss); 
程序例: 

#include 
#include 
#include 
#include 
#include 
#include 

int main(void) 
{ 
int handle; 
int status; 

handle = sopen("c:\\autoexec.bat", O_RDONLY, SH_DENYNO, S_IREAD); 

if (!handle) 
{ 
printf("sopen failed\n"); 
exit(1); 
} 

status = access("c:\\autoexec.bat", 6); 
if (status == 0) 
printf("read/write access allowed\n"); 
else 
printf("read/write access not allowed\n"); 

close(handle); 
return 0; 
} 




函数名: sound 
功 能: 以指定频率打开PC扬声器 
用 法: void sound(unsigned frequency); 
程序例: 

/* Emits a 7-Hz tone for 10 seconds. 
Your PC may not be able to emit a 7-Hz tone. */ 
#include 

int main(void) 
{ 
sound(7); 
delay(10000); 
nosound(); 
return 0; 
} 




函数名: spawnl 
功 能: 创建并运行子程序 
用 法: int spawnl(int mode, char *pathname, char *arg0, 
arg1, ... argn, NULL); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
int result; 

clrscr(); 
result = spawnl(P_WAIT, "tcc.exe", NULL); 
if (result == -1) 
{ 
perror("Error from spawnl"); 
exit(1); 
} 
return 0; 
} 



函数名: spawnle 
功 能: 创建并运行子程序 
用 法: int spawnle(int mode, char *pathname, char *arg0, 
arg1,..., argn, NULL); 
程序例: 

/* spawnle() example */ 

#include 
#include 
#include 

int main(void) 
{ 
int result; 

clrscr(); 
result = spawnle(P_WAIT, "tcc.exe", NULL, NULL); 
if (result == -1) 
{ 
perror("Error from spawnle"); 
exit(1); 
} 
return 0; 
} 




函数名: sprintf 
功 能: 送格式化输出到字符串中 
用 法: int sprintf(char *string, char *farmat [,argument,...]); 
程序例: 

#include 
#include 

int main(void) 
{ 
char buffer[80]; 

sprintf(buffer, "An approximation of Pi is %f\n", M_PI); 
puts(buffer); 
return 0; 
} 



函数名: sqrt 
功 能: 计算平方根 
用 法: double sqrt(double x); 
程序例: 

#include 
#include 

int main(void) 
{ 
double x = 4.0, result; 

result = sqrt(x); 
printf("The square root of %lf is %lf\n", x, result); 
return 0; 
} 


函数名: srand 
功 能: 初始化随机数发生器 
用 法: void srand(unsigned seed); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
int i; 
time_t t; 

srand((unsigned) time(&t)); 
printf("Ten random numbers from 0 to 99\n\n"); 
for(i=0; i<10; i++) 
printf("%d\n", rand() % 100); 
return 0; 
} 



函数名: sscanf 
功 能: 执行从字符串中的格式化输入 
用 法: int sscanf(char *string, char *format[,argument,...]); 
程序例: 

#include 
#include 

int main(void) 
{ 
char label[20]; 
char name[20]; 
int entries = 0; 
int loop, age; 
double salary; 

struct Entry_struct 
{ 
char name[20]; 
int age; 
float salary; 
} entry[20]; 

/* Input a label as a string of characters restricting to 20 characters */ 
printf("\n\nPlease enter a label for the chart: "); 
scanf("%20s", label); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* Input number of entries as an integer */ 
printf("How many entries will there be? (less than 20) "); 
scanf("%d", &entries); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a name restricting input to only letters upper or lower case */ 
for (loop=0;loop { 
printf("Entry %d\n", loop); 
printf(" Name : "); 
scanf("%[A-Za-z]", entry[loop].name); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input an age as an integer */ 
printf(" Age : "); 
scanf("%d", &entry[loop].age); 
fflush(stdin); /* flush the input stream in case of bad input */ 

/* input a salary as a float */ 
printf(" Salary : "); 
scanf("%f", &entry[loop].salary); 
fflush(stdin); /* flush the input stream in case of bad input */ 
} 

/* Input a name, age and salary as a string, integer, and double */ 
printf("\nPlease enter your name, age and salary\n"); 
scanf("%20s %d %lf", name, &age, &salary); 


/* Print out the data that was input */ 
printf("\n\nTable %s\n",label); 
printf("Compiled by %s age %d $%15.2lf\n", name, age, salary); 
printf("-----------------------------------------------------\n"); 
for (loop=0;loop printf("%4d | %-20s | %5d | %15.2lf\n", 
loop + 1, 
entry[loop].name, 
entry[loop].age, 
entry[loop].salary); 
printf("-----------------------------------------------------\n"); 
return 0; 
} 



函数名: stat 
功 能: 读取打开文件信息 
用 法: int stat(char *pathname, struct stat *buff); 
程序例: 

#include 
#include 
#include 

#define FILENAME "TEST.$$$" 

int main(void) 
{ 
struct stat statbuf; 
FILE *stream; 

/* open a file for update */ 
if ((stream = fopen(FILENAME, "w+")) == NULL) 
{ 
fprintf(stderr, "Cannot open output file.\n"); 
return(1); 
} 

/* get information about the file */ 
stat(FILENAME, &statbuf); 

fclose(stream); 

/* display the information returned */ 
if (statbuf.st_mode & S_IFCHR) 
printf("Handle refers to a device.\n"); 
if (statbuf.st_mode & S_IFREG) 
printf("Handle refers to an ordinary file.\n"); 
if (statbuf.st_mode & S_IREAD) 
printf("User has read permission on file.\n"); 
if (statbuf.st_mode & S_IWRITE) 
printf("User has write permission on file.\n"); 

printf("Drive letter of file: %c\n", 'A'+statbuf.st_dev); 
printf("Size of file in bytes: %ld\n", statbuf.st_size); 
printf("Time file last opened: %s\n", ctime(&statbuf.st_ctime)); 
return 0; 
} 




函数名: _status87 
功 能: 取浮点状态 
用 法: unsigned int _status87(void); 
程序例: 

#include 
#include 

int main(void) 
{ 
float x; 
double y = 1.5e-100; 

printf("Status 87 before error: %x\n", _status87()); 

x = y; /* <-- force an error to occur */ 
y = x; 

printf("Status 87 after error : %x\n", _status87()); 
return 0; 
} 



函数名: stime 
功 能: 设置时间 
用 法: int stime(long *tp); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
time_t t; 
struct tm *area; 

t = time(NULL); 
area = localtime(&t); 
printf("Number of seconds since 1/1/1970 is: %ld\n", t); 
printf("Local time is: %s", asctime(area)); 

t++; 
area = localtime(&t); 
printf("Add a second: %s", asctime(area)); 

t += 60; 
area = localtime(&t); 
printf("Add a minute: %s", asctime(area)); 

t += 3600; 
area = localtime(&t); 
printf("Add an hour: %s", asctime(area)); 

t += 86400L; 
area = localtime(&t); 
printf("Add a day: %s", asctime(area)); 

t += 2592000L; 
area = localtime(&t); 
printf("Add a month: %s", asctime(area)); 

t += 31536000L; 
area = localtime(&t); 
printf("Add a year: %s", asctime(area)); 
return 0; 
} 




函数名: stpcpy 
功 能: 拷贝一个字符串到另一个 
用 法: char *stpcpy(char *destin, char *source); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[10]; 
char *str1 = "abcdefghi"; 

stpcpy(string, str1); 
printf("%s\n", string); 
return 0; 
} 




函数名: strcat 
功 能: 字符串拼接函数 
用 法: char *strcat(char *destin, char *source); 
程序例: 

#include 
#include 

int main(void) 
{ 
char destination[25]; 
char *blank = " ", *c = "C++", *Borland = "Borland"; 

strcpy(destination, Borland); 
strcat(destination, blank); 
strcat(destination, c); 

printf("%s\n", destination); 
return 0; 
} 




函数名: strchr 
功 能: 在一个串中查找给定字符的第一个匹配之处\ 
用 法: char *strchr(char *str, char c); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[15]; 
char *ptr, c = 'r'; 

strcpy(string, "This is a string"); 
ptr = strchr(string, c); 
if (ptr) 
printf("The character %c is at position: %d\n", c, ptr-string); 
else 
printf("The character was not found\n"); 
return 0; 
} 




函数名: strcmp 
功 能: 串比较 
用 法: int strcmp(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "aaa", *buf2 = "bbb", *buf3 = "ccc"; 
int ptr; 

ptr = strcmp(buf2, buf1); 
if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 
else 
printf("buffer 2 is less than buffer 1\n"); 

ptr = strcmp(buf2, buf3); 
if (ptr > 0) 
printf("buffer 2 is greater than buffer 3\n"); 
else 
printf("buffer 2 is less than buffer 3\n"); 

return 0; 
} 




函数名: strncmpi 
功 能: 将一个串中的一部分与另一个串比较, 不管大小写 
用 法: int strncmpi(char *str1, char *str2, unsigned maxlen); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "BBB", *buf2 = "bbb"; 
int ptr; 

ptr = strcmpi(buf2, buf1); 

if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 

if (ptr < 0) 
printf("buffer 2 is less than buffer 1\n"); 

if (ptr == 0) 
printf("buffer 2 equals buffer 1\n"); 

return 0; 
} 




函数名: strcpy 
功 能: 串拷贝 
用 法: char *strcpy(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[10]; 
char *str1 = "abcdefghi"; 

strcpy(string, str1); 
printf("%s\n", string); 
return 0; 
} 




函数名: strcspn 
功 能: 在串中查找第一个给定字符集内容的段 
用 法: int strcspn(char *str1, char *str2); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
char *string1 = "1234567890"; 
char *string2 = "747DC8"; 
int length; 

length = strcspn(string1, string2); 
printf("Character where strings intersect is at position %d\n", length); 

return 0; 
} 




函数名: strdup 
功 能: 将串拷贝到新建的位置处 
用 法: char *strdup(char *str); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
char *dup_str, *string = "abcde"; 

dup_str = strdup(string); 
printf("%s\n", dup_str); 
free(dup_str); 

return 0; 
} 




函数名: stricmp 
功 能: 以大小写不敏感方式比较两个串 
用 法: int stricmp(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "BBB", *buf2 = "bbb"; 
int ptr; 

ptr = stricmp(buf2, buf1); 

if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 

if (ptr < 0) 
printf("buffer 2 is less than buffer 1\n"); 

if (ptr == 0) 
printf("buffer 2 equals buffer 1\n"); 

return 0; 
} 



函数名: strerror 
功 能: 返回指向错误信息字符串的指针 
用 法: char *strerror(int errnum); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buffer; 
buffer = strerror(errno); 
printf("Error: %s\n", buffer); 
return 0; 
} 




函数名: strcmpi 
功 能: 将一个串与另一个比较, 不管大小写 
用 法: int strcmpi(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "BBB", *buf2 = "bbb"; 
int ptr; 

ptr = strcmpi(buf2, buf1); 

if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 

if (ptr < 0) 
printf("buffer 2 is less than buffer 1\n"); 

if (ptr == 0) 
printf("buffer 2 equals buffer 1\n"); 

return 0; 
} 




函数名: strncmp 
功 能: 串比较 
用 法: int strncmp(char *str1, char *str2, int maxlen); 
程序例: 

#include 
#include 

int main(void) 

{ 
char *buf1 = "aaabbb", *buf2 = "bbbccc", *buf3 = "ccc"; 
int ptr; 

ptr = strncmp(buf2,buf1,3); 
if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 
else 
printf("buffer 2 is less than buffer 1\n"); 

ptr = strncmp(buf2,buf3,3); 
if (ptr > 0) 
printf("buffer 2 is greater than buffer 3\n"); 
else 
printf("buffer 2 is less than buffer 3\n"); 

return(0); 
} 



函数名: strncmpi 
功 能: 把串中的一部分与另一串中的一部分比较, 不管大小写 
用 法: int strncmpi(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "BBBccc", *buf2 = "bbbccc"; 
int ptr; 

ptr = strncmpi(buf2,buf1,3); 

if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 

if (ptr < 0) 
printf("buffer 2 is less than buffer 1\n"); 

if (ptr == 0) 
printf("buffer 2 equals buffer 1\n"); 

return 0; 
} 



函数名: strncpy 
功 能: 串拷贝 
用 法: char *strncpy(char *destin, char *source, int maxlen); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[10]; 
char *str1 = "abcdefghi"; 

strncpy(string, str1, 3); 
string[3] = '\0'; 
printf("%s\n", string); 
return 0; 
} 



函数名: strnicmp 
功 能: 不注重大小写地比较两个串 
用 法: int strnicmp(char *str1, char *str2, unsigned maxlen); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *buf1 = "BBBccc", *buf2 = "bbbccc"; 
int ptr; 

ptr = strnicmp(buf2, buf1, 3); 

if (ptr > 0) 
printf("buffer 2 is greater than buffer 1\n"); 

if (ptr < 0) 
printf("buffer 2 is less than buffer 1\n"); 

if (ptr == 0) 
printf("buffer 2 equals buffer 1\n"); 

return 0; 
} 




函数名: strnset 
功 能: 将一个串中的所有字符都设为指定字符 
用 法: char *strnset(char *str, char ch, unsigned n); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *string = "abcdefghijklmnopqrstuvwxyz"; 
char letter = 'x'; 

printf("string before strnset: %s\n", string); 
strnset(string, letter, 13); 
printf("string after strnset: %s\n", string); 

return 0; 
} 



函数名: strpbrk 
功 能: 在串中查找给定字符集中的字符 
用 法: char *strpbrk(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *string1 = "abcdefghijklmnopqrstuvwxyz"; 
char *string2 = "onm"; 
char *ptr; 

ptr = strpbrk(string1, string2); 

if (ptr) 
printf("strpbrk found first character: %c\n", *ptr); 
else 
printf("strpbrk didn't find character in set\n"); 

return 0; 
} 




函数名: strrchr 
功 能: 在串中查找指定字符的最后一个出现 
用 法: char *strrchr(char *str, char c); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[15]; 
char *ptr, c = 'r'; 

strcpy(string, "This is a string"); 
ptr = strrchr(string, c); 
if (ptr) 
printf("The character %c is at position: %d\n", c, ptr-string); 
else 
printf("The character was not found\n"); 
return 0; 
} 




函数名: strrev 
功 能: 串倒转 
用 法: char *strrev(char *str); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *forward = "string"; 

printf("Before strrev(): %s\n", forward); 
strrev(forward); 
printf("After strrev(): %s\n", forward); 
return 0; 
} 


函数名: strset 
功 能: 将一个串中的所有字符都设为指定字符 
用 法: char *strset(char *str, char c); 
程序例: 

#include 
#include 

int main(void) 
{ 
char string[10] = "123456789"; 
char symbol = 'c'; 

printf("Before strset(): %s\n", string); 
strset(string, symbol); 
printf("After strset(): %s\n", string); 
return 0; 
} 




函数名: strspn 
功 能: 在串中查找指定字符集的子集的第一次出现 
用 法: int strspn(char *str1, char *str2); 
程序例: 

#include 
#include 
#include 

int main(void) 
{ 
char *string1 = "1234567890"; 
char *string2 = "123DC8"; 
int length; 

length = strspn(string1, string2); 
printf("Character where strings differ is at position %d\n", length); 
return 0; 
} 



函数名: strstr 
功 能: 在串中查找指定字符串的第一次出现 
用 法: char *strstr(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *str1 = "Borland International", *str2 = "nation", *ptr; 

ptr = strstr(str1, str2); 
printf("The substring is: %s\n", ptr); 
return 0; 
} 



函数名: strtod 
功 能: 将字符串转换为double型值 
用 法: double strtod(char *str, char **endptr); 
程序例: 

#include 
#include 

int main(void) 
{ 
char input[80], *endptr; 
double value; 

printf("Enter a floating point number:"); 
gets(input); 
value = strtod(input, &endptr); 
printf("The string is %s the number is %lf\n", input, value); 
return 0; 
} 




函数名: strtok 
功 能: 查找由在第二个串中指定的分界符分隔开的单词 
用 法: char *strtok(char *str1, char *str2); 
程序例: 

#include 
#include 

int main(void) 
{ 
char input[16] = "abc,d"; 
char *p; 

/* strtok places a NULL terminator 
in front of the token, if found */ 
p = strtok(input, ","); 
if (p) printf("%s\n", p); 

/* A second call to strtok using a NULL 
as the first parameter returns a pointer 
to the character following the token */ 
p = strtok(NULL, ","); 
if (p) printf("%s\n", p); 
return 0; 
} 




函数名: strtol 
功 能: 将串转换为长整数 
用 法: long strtol(char *str, char **endptr, int base); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *string = "87654321", *endptr; 
long lnumber; 

/* strtol converts string to long integer */ 
lnumber = strtol(string, &endptr, 10); 
printf("string = %s long = %ld\n", string, lnumber); 

return 0; 
} 


函数名: strupr 
功 能: 将串中的小写字母转换为大写字母 
用 法: char *strupr(char *str); 
程序例: 

#include 
#include 

int main(void) 
{ 
char *string = "abcdefghijklmnopqrstuvwxyz", *ptr; 

/* converts string to upper case characters */ 
ptr = strupr(string); 
printf("%s\n", ptr); 
return 0; 
} 




函数名: swab 
功 能: 交换字节 
用 法: void swab (char *from, char *to, int nbytes); 
程序例: 

#include 
#include 
#include 

char source[15] = "rFna koBlrna d"; 
char target[15]; 

int main(void) 
{ 
swab(source, target, strlen(source)); 
printf("This is target: %s\n", target); 
return 0; 
} 




函数名: system 
功 能: 发出一个DOS命令 
用 法: int system(char *command); 
程序例: 

#include 
#include 

int main(void) 
{ 
printf("About to spawn command.com and run a DOS command\n"); 
system("dir"); 
return 0; 
} 